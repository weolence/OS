2.3 Реализуйте односвязный список, хранящий строки длиной менее 100 символов, у
которого с каждым элементом связан отдельный примитив синхронизации (за основу
можно взять реализацию списка, на котором построен очередь queue_t).

Объявление такого списка может выглядеть, например, так:
    typedef struct _Node {
        char value[100];
        struct _Node* next;
        pthread_mutex_t sync;
    } Node;

    typedef struct _Storage {
        Node *first;
    } Storage;

Первый поток пробегает по всему хранилищу и ищет количество пар строк, идущих по
возрастанию длины. Как только достигнут конец списка, поток инкрементирует
глобальную переменную, в которой хранится, количество выполненных им итераций и
сразу начинает новый поиск.

Второй поток пробегает по всему хранилищу и ищет количество пар строк, идущих по
убыванию длины. Как только достигнут конец списка, поток инкрементирует
глобальную переменную, в которой хранится количество выполненных им итераций и
сразу начинает новый поиск.

Третий поток пробегает по всему хранилищу и ищет количество пар строк, имеющих
одинаковую длину. Как только достигнут конец списка, поток инкрементирует
глобальную переменную, в которой хранится количество выполненных им итераций и
сразу начинает новый поиск.

Запускает 3 потока, которые в непрерывном бесконечном цикле случайным образом
проверяют - требуется ли переставлять соседние элементы списка (не значения) и
выполняют перестановку. Каждая успешная попытка перестановки фиксируется в
соответствующей глобальной переменной-счетчике.

Используйте для синхронизации доступа к элементам списка спинлоки, мутексы и
блокировки чтения-записи. Понаблюдайте как изменяются (и изменяются ли) значения
переменных счетчиков и объясните результат. Проверьте для списков длины 100, 1000,
10000, 100000

При реализации обратите внимание на следующие пункты:
- продумайте ваше решение, чтобы избежать ошибок соревнования.
- необходимо блокировать все записи с данными которых производится работа.
- при перестановке записей списка, необходимо блокировать три записи.
- чтобы избежать мертвых блокировок, примитивы записей, более близких к началу
списка, всегда захватывайте раньше.